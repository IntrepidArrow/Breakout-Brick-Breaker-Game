class Block223 {
   1 <@>- * PlayedGame playedGames;
   1 <@>- * HallOfFameEntry entries;
}

class Game {
   Boolean published = false;
   1 -> 0..1 HallOfFameEntry mostRecentEntry;
}

class PlayedGame {
   const Integer INITIAL_WAIT_TIME = 1000; // at design time, the initial wait time may be adjusted as seen fit
   autounique id;
   const Integer NR_LIVES = 3;
   Integer score = 0;
   Integer lives = NR_LIVES;
   Integer currentLevel = 1;
   Double waitTime = INITIAL_WAIT_TIME;
   * -- 0..1 Player player; // an admin may test the game; a game is played in test mode if player == null
   playername; // added here so that it only needs to be determined once
   
   // the PlayedBall and PlayedPaddle are not in a separate class to avoid the bug in Umple that occurred for the second constructor of Game

   // no direct link to Ball, because the ball can be found by navigating to PlayedGame, Game, and then Ball
   const Integer BALL_INITIAL_X = Game.PLAY_AREA_SIDE / 2;
   const Integer BALL_INITIAL_Y = Game.PLAY_AREA_SIDE / 2;
   // 0/0 is the top left corner of the play area, i.e., a directionX/Y of 0/1 moves the ball down in a straight line
   Double ballDirectionX = getGame().getBall().getMinBallSpeedX();
   Double ballDirectionY = getGame().getBall().getMinBallSpeedY();
   // the position of the ball is at the center of the ball
   defaulted Double currentBallX = BALL_INITIAL_X;
   defaulted Double currentBallY = BALL_INITIAL_Y;

   // no direct link to Paddle, because the paddle can be found by navigating to PlayedGame, Game, and then Paddle
   const Integer PADDLE_MOVE_RIGHT = 1; // pixels moved when right arrow key is pressed
   const Integer PADDLE_MOVE_LEFT = -1; // pixels moved when left arrow key is pressed
   Double currentPaddleLength = getGame().getPaddle().getMaxPaddleLength();
   // the position of the paddle is at its top right corner
   defaulted Double currentPaddleX = (Game.PLAY_AREA_SIDE - currentPaddleLength) / 2;
   immutable Double currentPaddleY = Game.PLAY_AREA_SIDE - Paddle.VERTICAL_DISTANCE - Paddle.PADDLE_WIDTH;

   * -- 1 Game game;
   1 <@>- * PlayedBlockAssignment blocks;
   0..1 -> 0..1 BouncePoint bounce;
   private BouncePoint calculateBouncePointBlock(PlayedBlockAssignment block) {
	BouncePoint bp = null;
	//BounceDirection br = null;
	int xBlock = block.getX();
	int yBlock = block.getY();
	int sideBlock = Block.SIZE;
	int ballRadius = Ball.BALL_DIAMETER / 2 ;
	Rectangle2D blockShape = new Rectangle2D.Double(xBlock,yBlock,sideBlock,sideBlock);
	Line2D ballTrajectory = new Line2D.Double(currentBallX,currentBallY,currentBallX + ballDirectionX, currentBallY + ballDirectionY);
	if(blockShape.intersectsLine(ballTrajectory)) {
		// segments representing the sides of the block
		Line2D blockTopLine = new Line2D.Double(xBlock,yBlock - ballRadius, xBlock + sideBlock, yBlock - ballRadius);
		Line2D blockBottomLine = new Line2D.Double(xBlock,yBlock + ballRadius + sideBlock, xBlock + sideBlock, yBlock + ballRadius + sideBlock);
		Line2D blockRightLine = new Line2D.Double(xBlock + ballRadius + sideBlock ,yBlock, xBlock + ballRadius + sideBlock, yBlock + sideBlock);
		Line2D blockLeftLine = new Line2D.Double(xBlock - ballRadius ,yBlock, xBlock - ballRadius, yBlock + sideBlock) ;
		QuadCurve2D upLeftCorner = new QuadCurve2D.Double(xBlock - ballRadius, yBlock,xBlock - ballRadius, yBlock - ballRadius,  xBlock, yBlock - ballRadius);
		QuadCurve2D upRightCorner = new QuadCurve2D.Double(xBlock + ballRadius + sideBlock, yBlock,xBlock + sideBlock + ballRadius, 
        		yBlock - ballRadius,  xBlock + sideBlock, yBlock - ballRadius); 
		QuadCurve2D lowRightCorner = new QuadCurve2D.Double(xBlock + sideBlock, yBlock + sideBlock + ballRadius,
        		xBlock + sideBlock + ballRadius, yBlock + sideBlock + ballRadius,  xBlock + sideBlock + ballRadius, yBlock + sideBlock);
		QuadCurve2D lowLeftCorner = new QuadCurve2D.Double(xBlock - ballRadius, yBlock + sideBlock,
        		xBlock - ballRadius, yBlock + sideBlock + ballRadius,  xBlock, yBlock + sideBlock + ballRadius);
		
		// check if hit the top of block
		
		// check if hit the bottom of block
		
		// check if hit the right side of block
		
		// check if hit the left side of block
		
		}
	
	return bp;
	
}
//helper 
  private int[] get_line_intersection(Line2D.Double pLine1, Line2D.Double pLine2)
  {
      int[] result = new int[2];

      double s1_x = pLine1.x2 - pLine1.x1,
          s1_y = pLine1.y2 - pLine1.y1,

          s2_x = pLine2.x2 - pLine2.x1,
          s2_y = pLine2.y2 - pLine2.y1,

          s = (-s1_y * (pLine1.x1 - pLine2.x1) + s1_x * (pLine1.y1 - pLine2.y1)) / (-s2_x * s1_y + s1_x * s2_y),
          t = ( s2_x * (pLine1.y1 - pLine2.y1) - s2_y * (pLine1.x1 - pLine2.x1)) / (-s2_x * s1_y + s1_x * s2_y);

      if (s >= 0 && s <= 1 && t >= 0 && t <= 1)
      {
          // Collision detected
          result[0] =(int) (pLine1.x1 + (t * s1_x));
          result[1] = (int) (pLine1.y1 + (t * s1_y));
      }   // end if

      return result;
  }
}

class PlayedBlockAssignment {
   // the associated block is either (a) the same as the one of the corresponding BlockAssignent or (b) randomly chosen
   * -- 1 Block block;
   // the position of a block is at its top right corner
   Integer x;
   Integer y;
}

class HallOfFameEntry {
   Integer score;
   playername; // added here so that it only needs to be determined once
   * -- 1 Player player;
   // the sorted keyword keeps the list of entries in the game automatically sorted by the score
   * sorted {score} -- 1 Game game;
}

// this class needs to be specified but the use of it is optional; it is also not added to the persistence file
// you may implement bounce behavior differently
class BouncePoint {
   Double x;
   Double y;
   enum BounceDirection { FLIP_X, FLIP_Y, FLIP_BOTH }
   BounceDirection direction;
   0..1 -> 0..1 PlayedBlockAssignment hitBlock;
}